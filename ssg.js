const fs = require('fs');
const path = require('path');
const https = require('https');

// Basic slugify function
function slugify(input) {
  return String(input)
    .toLowerCase()
    .replace(/\s+/g, '-')           // Replace spaces with -
    .replace(/\-\-+/g, '-')         // Replace multiple - with single -
    .replace(/[^\w\-]+/g, '')       // Remove all non-word chars
    .replace(/^-+/, '')             // Trim - from start of text
    .replace(/-+$/, '');            // Trim - from end of text
}

// Load config
const config = JSON.parse(fs.readFileSync('config.json', 'utf8'));

// Ensure output directory exists
if (!fs.existsSync(config.outputDir)) {
  fs.mkdirSync(config.outputDir, { recursive: true });
}

// Load templates
const templates = {
  base: fs.readFileSync(path.join('themes', config.template, 'baseof.html'), 'utf8'),
  single: fs.readFileSync(path.join('themes', config.template, 'single.html'), 'utf8'),
  list: fs.readFileSync(path.join('themes', config.template, 'list.html'), 'utf8'),
  pagination: fs.readFileSync(path.join('themes', config.template, 'pagination.html'), 'utf8'),
  taxonomy: fs.readFileSync(path.join('themes', config.template, 'taxonomy.html'), 'utf8'),
  terms: fs.readFileSync(path.join('themes', config.template, 'terms.html'), 'utf8')
};

// Fetch data helper
async function fetchData(url) {
  return new Promise((resolve, reject) => {
    https.get(url, (res) => {
      let data = '';
      res.on('data', (chunk) => data += chunk);
      res.on('end', () => {
        try {
          resolve(JSON.parse(data));
        } catch (e) {
          reject(`Error parsing JSON from ${url}: ${e.message}`);
        }
      });
    }).on('error', (err) => reject(`Error fetching ${url}: ${err.message}`));
  });
}

// Generate pagination HTML
function getPaginationHTML(currentPage, totalPages, filenamePattern) {
  // Basic check to prevent errors if pagination template is complex and expects these
  if (!templates.pagination) return '';
  try {
    return new Function(
      'currentPage',
      'totalPages',
      'filenamePattern',
      `return \`${templates.pagination}\``
    )(currentPage, totalPages, filenamePattern);
  } catch (e) {
    console.warn(`Error processing pagination template: ${e.message}`);
    return ''; // Return empty string on error
  }
}

// Generate HTML with template literals - Modified for selective logging
function generateHTML(templateName, data, outputPath, pagination = '', generationType, generationStats) {
  const template = templates[templateName];
  if (!template) {
      console.error(`Error: Template "${templateName}" not found.`);
      return; // Stop if template is missing
  }
  if (!templates.base) {
      console.error(`Error: Base template "baseof.html" not found.`);
      return; // Stop if base template is missing
  }

  // Create a context object with data, pagination, and our helper functions
  const context = {
    ...data,
    pagination,
    slugify: (input) => slugify(input), // Add slugify directly to the context
    content: '' // Placeholder for content generated by specific template
  };

  let content = '';
  try {
    // Evaluate the specific template (single, list, etc.)
    content = new Function(
      'data',
      `with(data) { return \`${template}\` }`
    )(context);
  } catch (e) {
      console.error(`Error processing template "${templateName}" for ${outputPath}: ${e.message}`);
      // Optionally add more context: console.error("Data:", JSON.stringify(data).substring(0, 200));
      return; // Stop generation for this file on template error
  }


  let fullHTML = '';
  try {
    // Evaluate the base template, injecting the generated content
    fullHTML = new Function(
      'data',
      `with(data) { return \`${templates.base}\` }`
    )({ ...context, content }); // Pass content generated above
  } catch (e) {
      console.error(`Error processing base template for ${outputPath}: ${e.message}`);
      // Optionally add more context: console.error("Data:", JSON.stringify(context).substring(0, 200));
      return; // Stop generation for this file on base template error
  }


  // --- Logging Logic ---
  const MAX_LOGS_PER_TYPE = 3;
  if (generationStats && generationStats[generationType]) {
    generationStats[generationType].count++; // Increment total count

    // Log only the first few for this type
    if (generationStats[generationType].logged < MAX_LOGS_PER_TYPE) {
      console.log(`Generated [${generationType}]: ${outputPath}`);
      generationStats[generationType].logged++;
    } else if (generationStats[generationType].logged === MAX_LOGS_PER_TYPE) {
      // Log a message indicating further logs for this type are suppressed
      console.log(`... (further logs for ${generationType} suppressed)`);
      generationStats[generationType].logged++; // Increment once more to prevent re-logging this message
    }
  } else {
    // Fallback if stats object is missing or type is unknown (shouldn't happen ideally)
    console.log(`Generated (untracked): ${outputPath}`);
  }
  // --- End Logging Logic ---

  try {
    fs.writeFileSync(outputPath, fullHTML);
  } catch (e) {
      console.error(`Error writing file ${outputPath}: ${e.message}`);
  }
}

// Process taxonomies with base path - Modified for selective logging
async function processTaxonomies(allItems, basePath, generationStats) {
  if (!config.taxonomies || !Array.isArray(config.taxonomies)) return;

  for (const taxonomy of config.taxonomies) {
    const taxonomySlug = slugify(taxonomy);
    const taxonomyDir = path.join(basePath, taxonomySlug);

    if (!fs.existsSync(taxonomyDir)) {
      fs.mkdirSync(taxonomyDir, { recursive: true });
    }

    const termsMap = new Map();

    // Group items by term
    for (const item of allItems) {
        let itemTerms = item[taxonomy];
        if (itemTerms) {
            // Ensure it's an array, handle single string values
            if (!Array.isArray(itemTerms)) {
                itemTerms = [itemTerms];
            }

            for (const term of itemTerms) {
                // Handle both simple strings and objects like { name: 'term' }
                const termName = (typeof term === 'object' && term !== null && term.name) ? term.name : String(term);
                if (!termName) continue; // Skip empty/invalid terms

                const termSlug = slugify(termName);

                if (!termsMap.has(termSlug)) {
                    termsMap.set(termSlug, {
                        name: termName,
                        items: []
                    });
                }
                termsMap.get(termSlug).items.push(item);
            }
        }
    }


    // Generate term pages (e.g., /tags/javascript.html)
    for (const [termSlug, termData] of termsMap) {
      const { name, items } = termData;

      if (config.pagination && config.pagination.itemsPerPage > 0) {
        const itemsPerPage = config.pagination.itemsPerPage;
        const totalPages = Math.ceil(items.length / itemsPerPage);
        const filenamePattern = config.pagination.filenamePattern || 'page-*.html'; // Use default if not set

        for (let page = 1; page <= totalPages; page++) {
          const pageItems = items.slice((page - 1) * itemsPerPage, page * itemsPerPage);
          const paginationHTML = getPaginationHTML(page, totalPages, filenamePattern.replace('*', page)); // Pass actual filename for link generation
          const pageFilename = page === 1 ? `${termSlug}.html` : `${termSlug}-${filenamePattern.replace('*', page)}`;
          const outputPath = path.join(taxonomyDir, pageFilename);

          generateHTML('taxonomy', {
            items: pageItems,
            term: name,
            taxonomy: taxonomy,
            currentPage: page,
            totalPages: totalPages
          }, outputPath, paginationHTML, 'taxonomy_term', generationStats); // Pass type and stats
        }
      } else {
        // No pagination for taxonomy terms
        generateHTML('taxonomy', {
          items: items,
          term: name,
          taxonomy: taxonomy
        }, path.join(taxonomyDir, `${termSlug}.html`), '', 'taxonomy_term', generationStats); // Pass type and stats
      }
    }

    // Generate terms list page (e.g., /tags/index.html)
    const termsList = Array.from(termsMap.entries()).map(([slug, termData]) => ({
      name: termData.name,
      slug: slug, // The slug of the term page (without pagination part)
      path: path.join('/', slugify(config.path || ''), taxonomySlug, `${slug}.html`).replace(/\\/g, '/'), // Generate relative URL path
      count: termData.items.length
    })).sort((a, b) => a.name.localeCompare(b.name)); // Sort terms alphabetically

    generateHTML('terms', {
      terms: termsList,
      taxonomy: taxonomy
    }, path.join(taxonomyDir, 'index.html'), '', 'taxonomy_list', generationStats); // Pass type and stats
  }
}

// Main generation function
async function generateSite() {
  // Initialize stats object
  const generationStats = {
    single: { count: 0, logged: 0 },
    list: { count: 0, logged: 0 },
    taxonomy_term: { count: 0, logged: 0 },
    taxonomy_list: { count: 0, logged: 0 },
  };

  console.log('Starting site generation...');

  try {
    // Load data
    const allItems = [];
    console.log('Fetching data...');
    for (const dataUrl of config.data) {
      try {
        const data = await fetchData(dataUrl);
        // Ensure data is always an array for consistent processing
        if (Array.isArray(data)) {
            allItems.push(...data);
        } else if (data && typeof data === 'object') {
            // Handle case where a URL might return a single object instead of an array
            allItems.push(data);
        } else {
            console.warn(`Data from ${dataUrl} is not an array or object, skipping.`);
        }
      } catch (fetchError) {
          console.error(`Failed to fetch or parse data from ${dataUrl}: ${fetchError}`);
          // Decide if you want to stop generation or continue with partial data
          // For now, we'll log the error and continue
      }
    }
    console.log(`Fetched ${allItems.length} total items.`);


    // Create base path directory if specified in config
    const siteBasePath = config.path ? slugify(config.path) : '';
    const outputBasePath = path.join(config.outputDir, siteBasePath);
    if (!fs.existsSync(outputBasePath)) {
      fs.mkdirSync(outputBasePath, { recursive: true });
    }

    // Generate individual pages (e.g., /posts/my-first-post.html)
    console.log('Generating single item pages...');
    for (const item of allItems) {
      // Ensure item has a title or some identifier for slug generation
      const identifier = item.title || item.name || item.id;
      if (!identifier) {
          console.warn('Skipping item without title, name, or id:', JSON.stringify(item).substring(0, 100));
          continue;
      }
      const itemSlug = item.slug || slugify(identifier);
      generateHTML('single', item, path.join(outputBasePath, `${itemSlug}.html`), '', 'single', generationStats); // Pass type and stats
    }

    // Generate paginated list pages (e.g., /posts/index.html, /posts/page-2.html)
    console.log('Generating list pages...');
    if (config.pagination && config.pagination.itemsPerPage > 0 && allItems.length > 0) {
      const itemsPerPage = config.pagination.itemsPerPage;
      const totalPages = Math.ceil(allItems.length / itemsPerPage);
      const filenamePattern = config.pagination.filenamePattern || 'page-*.html'; // Use default if not set

      for (let page = 1; page <= totalPages; page++) {
        const pageItems = allItems.slice((page - 1) * itemsPerPage, page * itemsPerPage);
        const paginationHTML = getPaginationHTML(page, totalPages, filenamePattern.replace('*', page)); // Pass actual filename for link generation
        const pageFilename = page === 1 ? 'index.html' : filenamePattern.replace('*', page);
        const outputPath = path.join(outputBasePath, pageFilename);

        generateHTML('list', {
            items: pageItems,
            currentPage: page,
            totalPages: totalPages
        }, outputPath, paginationHTML, 'list', generationStats); // Pass type and stats
      }
    } else if (allItems.length > 0) {
      // Generate a single list page if pagination is disabled or no items
      generateHTML('list', { items: allItems }, path.join(outputBasePath, 'index.html'), '', 'list', generationStats); // Pass type and stats
    } else {
        console.log('No items found, skipping list page generation.');
    }

    // Process taxonomies (e.g., /tags/, /categories/)
    console.log('Processing taxonomies...');
    await processTaxonomies(allItems, outputBasePath, generationStats); // Pass stats object

    // --- Final Summary ---
    console.log('\n--- Generation Summary ---');
    let totalFiles = 0;
    for (const type in generationStats) {
      if (generationStats[type].count > 0) {
        const typeName = type.replace(/_/g, ' '); // Make it more readable
        console.log(`Total ${typeName} pages generated: ${generationStats[type].count}`);
        totalFiles += generationStats[type].count;
      }
    }
     console.log(`Total files generated: ${totalFiles}`);
    console.log('--------------------------');
    console.log('Site generation complete!');
    // --- End Final Summary ---

  } catch (error) {
    console.error('FATAL Error during site generation:', error);
    process.exit(1); // Exit with error code if something major went wrong
  }
}

generateSite();
